--- old/make/bsd/makefiles/gcc.make	2019-06-27 16:39:21.000000000 -0400
+++ new/make/bsd/makefiles/gcc.make	2019-06-27 16:39:20.000000000 -0400
@@ -363,7 +363,15 @@
 # Linker flags
 
 # statically link libstdc++.so, work with gcc but ignored by g++
-STATIC_STDCXX = -Wl,-Bstatic -lstdc++ -Wl,-Bdynamic
+ifeq ($(OS_VENDOR), Darwin)
+  ifeq ($(USE_CLANG), true)
+    STATIC_STDCXX = -Wl,-Bstatic -lc++ -Wl,-Bdynamic
+  else
+    STATIC_STDCXX = -Wl,-Bstatic -lstdc++ -Wl,-Bdynamic
+  endif
+else
+  STATIC_STDCXX = -Wl,-Bstatic -lstdc++ -Wl,-Bdynamic
+endif
 
 ifeq ($(USE_CLANG),)
   # statically link libgcc and/or libgcc_s, libgcc does not exist before gcc-3.x.
--- old/src/os/aix/vm/decoder_aix.hpp	2019-06-27 16:39:22.000000000 -0400
+++ new/src/os/aix/vm/decoder_aix.hpp	2019-06-27 16:39:22.000000000 -0400
@@ -32,7 +32,7 @@
   AIXDecoder() {
     _decoder_status = no_error;
   }
-  ~AIXDecoder() {}
+  virtual ~AIXDecoder() {}
 
   virtual bool can_decode_C_frame_in_vm() const { return true; }
 
--- old/src/os/bsd/vm/decoder_machO.hpp	2019-06-27 16:39:24.000000000 -0400
+++ new/src/os/bsd/vm/decoder_machO.hpp	2019-06-27 16:39:23.000000000 -0400
@@ -34,7 +34,7 @@
 class MachODecoder : public AbstractDecoder {
  public:
   MachODecoder() { }
-  ~MachODecoder() { }
+  virtual ~MachODecoder() { }
   virtual bool can_decode_C_frame_in_vm() const {
     return true;
   }
--- old/src/os/windows/vm/decoder_windows.hpp	2019-06-27 16:39:25.000000000 -0400
+++ new/src/os/windows/vm/decoder_windows.hpp	2019-06-27 16:39:25.000000000 -0400
@@ -56,7 +56,7 @@
 
 public:
   WindowsDecoder();
-  ~WindowsDecoder() { uninitialize(); };
+  virtual ~WindowsDecoder() { uninitialize(); };
 
   bool can_decode_C_frame_in_vm() const;
   bool demangle(const char* symbol, char *buf, int buflen);
--- old/src/share/vm/classfile/classLoader.hpp	2019-06-27 16:39:26.000000000 -0400
+++ new/src/share/vm/classfile/classLoader.hpp	2019-06-27 16:39:26.000000000 -0400
@@ -39,7 +39,7 @@
   int    _num_meta_package_names;
  public:
   MetaIndex(char** meta_package_names, int num_meta_package_names);
-  ~MetaIndex();
+  virtual ~MetaIndex();
   bool may_contain(const char* class_name);
 };
 
@@ -61,6 +61,7 @@
   virtual bool is_lazy();
   // Constructor
   ClassPathEntry();
+  virtual ~ClassPathEntry() {}
   // Attempt to locate file_name through this class path entry.
   // Returns a class file parsing stream if successfull.
   virtual ClassFileStream* open_stream(const char* name, TRAPS) = 0;
@@ -77,6 +78,7 @@
   bool is_jar_file()  { return false;  }
   const char* name()  { return _dir; }
   ClassPathDirEntry(const char* dir);
+  virtual ~ClassPathDirEntry() {}
   ClassFileStream* open_stream(const char* name, TRAPS);
   // Debugging
   NOT_PRODUCT(void compile_the_world(Handle loader, TRAPS);)
@@ -106,7 +108,7 @@
   bool is_jar_file()  { return true;  }
   const char* name()  { return _zip_name; }
   ClassPathZipEntry(jzfile* zip, const char* zip_name);
-  ~ClassPathZipEntry();
+  virtual ~ClassPathZipEntry();
   u1* open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS);
   ClassFileStream* open_stream(const char* name, TRAPS);
   void contents_do(void f(const char* name, void* context), void* context);
@@ -134,6 +136,7 @@
   bool is_jar_file();
   const char* name()  { return _path; }
   LazyClassPathEntry(const char* path, const struct stat* st, bool throw_exception);
+  virtual ~LazyClassPathEntry() {}
   u1* open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS);
   ClassFileStream* open_stream(const char* name, TRAPS);
   void set_meta_index(MetaIndex* meta_index) { _meta_index = meta_index; }
--- old/src/share/vm/prims/jvmtiImpl.hpp	2019-06-27 16:39:28.000000000 -0400
+++ new/src/share/vm/prims/jvmtiImpl.hpp	2019-06-27 16:39:28.000000000 -0400
@@ -64,6 +64,7 @@
 
 class GrowableElement : public CHeapObj<mtInternal> {
 public:
+  virtual ~GrowableElement() {}
   virtual address getCacheValue()          =0;
   virtual bool equals(GrowableElement* e)  =0;
   virtual bool lessThan(GrowableElement *e)=0;
--- old/src/share/vm/runtime/perfData.hpp	2019-06-27 16:39:29.000000000 -0400
+++ new/src/share/vm/runtime/perfData.hpp	2019-06-27 16:39:29.000000000 -0400
@@ -288,7 +288,7 @@
     void *_valuep;
 
     PerfData(CounterNS ns, const char* name, Units u, Variability v);
-    ~PerfData();
+    virtual ~PerfData();
 
     // create the entry for the PerfData item in the PerfData memory region.
     // this region is maintained separately from the PerfData objects to
--- old/src/share/vm/utilities/decoder.hpp	2019-06-27 16:39:31.000000000 -0400
+++ new/src/share/vm/utilities/decoder.hpp	2019-06-27 16:39:30.000000000 -0400
@@ -32,6 +32,7 @@
 
 class AbstractDecoder : public CHeapObj<mtInternal> {
 public:
+  virtual ~AbstractDecoder() {}
   // status code for decoding native C frame
   enum decoder_status {
          not_available = -10,  // real decoder is not available
@@ -78,7 +79,7 @@
     _decoder_status = not_available;
   }
 
-  ~NullDecoder() {};
+  virtual ~NullDecoder() {};
 
   virtual bool decode(address pc, char* buf, int buflen, int* offset,
     const char* modulepath = NULL) {
--- old/src/share/vm/utilities/decoder_elf.hpp	2019-06-27 16:39:32.000000000 -0400
+++ new/src/share/vm/utilities/decoder_elf.hpp	2019-06-27 16:39:32.000000000 -0400
@@ -37,7 +37,7 @@
     _opened_elf_files = NULL;
     _decoder_status = no_error;
   }
-  ~ElfDecoder();
+  virtual ~ElfDecoder();
 
   bool can_decode_C_frame_in_vm() const { return true; }
 
